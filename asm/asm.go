package asm

import (
    //. "github.com/derlaft/figex/mio"
    //"strconv"
)

//
// INSTRUCTIONS
//

type InstHandler func(*State, Instruction)

// Instruction map
var Handlers = map[string]InstHandler {
    // Ariphmetic instructions
    "ADD": Add,
    "SUB": Sub,
    "INC": Inc,
    "DEC": Dec,
    "MUL": Mul,
    "DIV": Div,
    // Logic instructions
    "AND": And,
    "OR":  Or,
    "XOR": Xor,
    "NOT": Not,
    // Shift instructions
    "ROL": Rol,
    "ROR": Ror,
    "RCL": Rcl,
    "RCR": Rcr,
    // Data move instructions
    "MOV": Mov,
    "LD":  Ld,
    "ST":  St,
    // Programm stack instructions
    "PUT": Push,
    "POP": Pop,
    // Compare instruction
//    "CMP": Cmp,
    // Jumps instructions
    "JZ":  Jz,
    "JNZ": Jnz,
    "JO":  Jo,
    "JNO": Jno,
    "JF":  Jf,
    "JNF": Jnf,
    "JI": Ji,
    "JNI": Jni,
    "JL": Jl,
    "JNL": Jnl,
    "JE": Je,
    "JNE": Jne,
    "JG": Jg,
    "JNG": Jng,
    "JMP": Jmp,
    // Procedure instructions
    "CAL": Call,
    "RET": Ret,
    // Fault instruction
    "Flt": Flt,
    // Software interrupt
//    "INT": Int,
}

// Instruction that changes first operand (return values)
var RetInstructions = map[string]bool {
    "ADD": true,
    "SUB": true,
    "INC": true,
    "DEC": true,
    "MUL": true,
    "DIV": true,
    "AND": true,
    "OR":  true,
    "XOR": true,
    "NOT": true,
    "ROL": true,
    "ROR": true,
    "RCL": true,
    "RCR": true,
    "MOV": true,
    "LD":  true,
    "POP": true,
}

// Instruction argument
type Argument struct {
    Type byte
    Val int
}

// Argument types: register, constant, label
const (
    ARG_REG = 0
    ARG_CONST = 1
    ARG_LABEL = 2
)

// Command structure (generated by parser?)
type Command struct {
    InstName string   // Instruction name
    Args [2]Argument  // Instruction arguments
    Used byte         // FIXME: WUT?
}

// Instruction structure
type Instruction struct {
    handler InstHandler     // Instruction handler
    Args [2]byte            // Arguments
    JumpAddr int            // Jump address
    RetPtr *byte            // Return value pointer
}

// Generate instruction from command
func (cmd *Command) toInstruction(state *State) Instruction {

    inst := Instruction{}
    inst.handler = Handlers[cmd.InstName]

    for i, arg := range cmd.Args {
        switch arg.Type {
            case ARG_REG:
                reg := arg.Val & 0xF
                inst.Args[i] = state.Reg[reg]
                if i == 0 {
                    inst.RetPtr = &state.Reg[reg]
                }
            case ARG_CONST:
                inst.Args[i] = byte(arg.Val)
            case ARG_LABEL:
                inst.JumpAddr = arg.Val
        }
    }

    if RetInstructions[cmd.InstName] && inst.RetPtr == nil {
        inst.handler = Flt
    }

    return inst
}

//
// MACHINE STATE
//

// Digital machine state structure
type State struct {
    Reg [16]byte    // Registers: R0 ... RD, Stack pointer: RE (RSP), Flags RF
    Mem [256]byte   // Data memory
    IP int          // Instruction pointer (untouchable)
    Ret [32]int     // Returning stack array (untouchable)
    Rpt byte        // Return from procedure pointer
}

// Register alternate names
const (
    RA = 10
    RB = 11
    RC = 12
    RD = 13
    RE = 14 // Programm stack pointer register
    RSP = 14
    RF = 15 // Flag register
)

// Digital machine cycle
func (state *State) Cycle(cmd Command) error {

    // state.Reg[RF] = 0 //WARNING: flush RF before EACH instrution not good way
    inst := cmd.toInstruction(state)
    inst.handler(state, inst)
    state.IP += 1

    return nil
}

// Get instructin pointer
func (state *State) GetIP() int {
    return state.IP
}

//
// HANDLERS REALISATION
//

// JUMPS

func Jmp(state *State, inst Instruction) {
    state.IP = inst.JumpAddr
}

func JmpIfFlag(state *State, inst Instruction, flag byte, rev bool) {
    if ( (state.Reg[RF] & (1 << flag) > 0) == rev ) {
        Jmp(state, inst)
    }
}

// Flag register structure
const (
    F_ZERO = 0
    F_OVER = 1
    F_FAULT = 2
    F_INT = 3
    F_LESS = 4
    F_EQUAL = 5
    F_GREAT = 6
)

func Jz(state *State, inst Instruction) {
    JmpIfFlag(state, inst, F_ZERO, false)
}

func Jnz(state *State, inst Instruction) {
    JmpIfFlag(state, inst, F_ZERO, true)
}

func Jo(state *State, inst Instruction) {
    JmpIfFlag(state, inst, F_OVER, false)
}

func Jno(state *State, inst Instruction) {
    JmpIfFlag(state, inst, F_OVER, true)
}

func Jf(state *State, inst Instruction) {
    JmpIfFlag(state, inst, F_FAULT, false)
}

func Jnf(state *State, inst Instruction) {
    JmpIfFlag(state, inst, F_FAULT, true)
}

func Ji(state *State, inst Instruction) {
    JmpIfFlag(state, inst, F_INT, false)
}

func Jni(state *State, inst Instruction) {
    JmpIfFlag(state, inst, F_INT, true)
}

func Jl(state *State, inst Instruction) {
    JmpIfFlag(state, inst, F_LESS, false)
}

func Jnl(state *State, inst Instruction) {
    JmpIfFlag(state, inst, F_LESS, true)
}

func Je(state *State, inst Instruction) {
    JmpIfFlag(state, inst, F_EQUAL, false)
}

func Jne(state *State, inst Instruction) {
    JmpIfFlag(state, inst, F_EQUAL, true)
}

func Jg(state *State, inst Instruction) {
    JmpIfFlag(state, inst, F_GREAT, false)
}

func Jng(state *State, inst Instruction) {
    JmpIfFlag(state, inst, F_GREAT, true)
}

// PROCEDURES

func Call(state *State, inst Instruction) {

    if state.Rpt == 31 {
        state.Reg[RF] |= (1 << F_FAULT)
        return
    }

    state.Rpt += 1
    state.Ret[state.Rpt] = state.IP
    state.IP = inst.JumpAddr
}

func Ret(state *State, inst Instruction) {

    if state.Rpt == 0 {
        state.Reg[RF] |= (1 << F_FAULT)
        return
    }

    state.IP = state.Ret[state.Rpt]
    state.Rpt -= 1
}

// OTHER OPERATIONS

// Dual args flags: LESS, EQUAL, GREAT
func (state *State) flagArgs(first byte, second byte) {

    if first < second {
        state.Reg[RF] |= (1 << F_LESS)
    }

    if first == second {
        state.Reg[RF] |= (1 << F_EQUAL)
    }

    if first > second {
        state.Reg[RF] |= (1 << F_GREAT)
    }
}

// Range flags: OVER, FAULT, ZERO
func (state *State) flagResult(result int) byte {

    // Check byte bounds
    if result < 0 {
        result = -result // WARNING: may be need zero value or `0xFF - result`
        state.Reg[RF] |= (1 << F_FAULT)
    }

    if result > 0xFF {
        result = result & 0xFF
        state.Reg[RF] |= (1 << F_OVER)
    }

    // Check for zero
    if result == 0 {
        state.Reg[RF] |= (1 << F_ZERO)
    }

    return byte(result)
}


func Add(state *State, inst Instruction) {
    state.Reg[RF] = 0
    first  := inst.Args[0]
    second := inst.Args[1]
    state.flagArgs(first, second)
    *inst.RetPtr= state.flagResult(int(first) + int(second))
}

func Sub(state *State, inst Instruction) {
    state.Reg[RF] = 0
    first  := inst.Args[0]
    second := inst.Args[1]
    state.flagArgs(first, second)
    *inst.RetPtr= state.flagResult(int(first) - int(second))
}

func Inc(state *State, inst Instruction) {
    state.Reg[RF] = 0
    *inst.RetPtr= state.flagResult(int(inst.Args[0]) + 1)
}

func Dec(state *State, inst Instruction) {
    state.Reg[RF] = 0
    *inst.RetPtr= state.flagResult(int(inst.Args[0]) - 1)
}

func Mul(state *State, inst Instruction) {
    state.Reg[RF] = 0
    first  := inst.Args[0]
    second := inst.Args[1]
    state.flagArgs(first, second)
    *inst.RetPtr= state.flagResult(int(first) * int(second))
}

func Div(state *State, inst Instruction) {
    state.Reg[RF] = 0
    first  := inst.Args[0]
    second := inst.Args[1]
    state.flagArgs(first, second)
    
    // FIXME
    if inst.Args[1] != 0 {
        *inst.RetPtr= byte(int(inst.Args[0]) / int(inst.Args[1]))
        state.Reg[RA] = (byte) (int(inst.Args[0]) % int(inst.Args[1]))
    } else {
        state.Reg[RF] |= (1 << F_FAULT)
    }
}

func And(state *State, inst Instruction) {
    state.Reg[RF] = 0
    first  := inst.Args[0]
    second := inst.Args[1]
    state.flagArgs(first, second)
    *inst.RetPtr= state.flagResult(int(first) & int(second))
}

func Or(state *State, inst Instruction) {
    state.Reg[RF] = 0
    first  := inst.Args[0]
    second := inst.Args[1]
    state.flagArgs(first, second)
    *inst.RetPtr= state.flagResult(int(first) | int(second))
}

func Xor(state *State, inst Instruction) {
    state.Reg[RF] = 0
    first  := inst.Args[0]
    second := inst.Args[1]
    state.flagArgs(first, second)
    *inst.RetPtr= state.flagResult(int(first) ^ int(second))
}

func Not(state *State, inst Instruction) {
    state.Reg[RF] = 0
    *inst.RetPtr= state.flagResult(int(inst.Args[0] ^ 0xFF))
}

func Rol(state *State, inst Instruction) {
    state.Reg[RF] = 0
    *inst.RetPtr= state.flagResult(int(inst.Args[0] << 1))
}

func Ror(state *State, inst Instruction) {
    state.Reg[RF] = 0
    *inst.RetPtr= state.flagResult(int(inst.Args[0] >> 1))
}

func Rcl(state *State, inst Instruction) {
    state.Reg[RF] = 0
    *inst.RetPtr= state.flagResult(int(inst.Args[0] << 1) | int(inst.Args[0] >> 7))
}

func Rcr(state *State, inst Instruction) {
    state.Reg[RF] = 0
    *inst.RetPtr= state.flagResult(int(inst.Args[0] >> 1) | int(inst.Args[0] << 7))
}

// Data move

func Mov(state *State, inst Instruction) {
    *inst.RetPtr= state.flagResult(int(inst.Args[1]))
}

func Ld(state *State, inst Instruction) {
    *inst.RetPtr= state.Mem[inst.Args[1]]
}

func St(state *State, inst Instruction) {
    state.Mem[inst.Args[1]] = inst.Args[0]
}

// Stack

func Push(state *State, inst Instruction) {
    if state.Reg[RSP] < 128 || state.Reg[RSP] > 127 + 64 {
        state.Reg[RF] |= (1 << F_FAULT)
    } else {
        state.Mem[state.Reg[RSP]] = inst.Args[0]
        state.Reg[RSP] = byte(int(state.Reg[RSP]) + 1)
    }
}

func Pop(state *State, inst Instruction) {
    if state.Reg[RSP] < 128 || state.Reg[RSP] > 127 + 64 {
        state.Reg[RF] |= (1 << F_FAULT)
    } else {
        state.Reg[RSP] = byte(int(state.Reg[RSP]) - 1)
        *inst.RetPtr= state.flagResult(int(state.Mem[state.Reg[RSP]]))
    }
}


// Generate fault state
func Flt(state *State, inst Instruction) {
    state.Reg[RF] |= (1 << F_FAULT)
}

// Nop-nop-nop
func Nop(state *State, inst Instruction) {
}
